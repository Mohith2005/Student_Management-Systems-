<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Computer Science - MCQ Exam</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
        }

        body {
            background: #f0f2f5;
        }

        .header {
            background: #4c6ef5;
            color: white;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .timer {
            background: white;
            color: black;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 2rem;
        }

        .main-content {
            background: white;
            border-radius: 8px;
            padding: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .question {
            margin-bottom: 2rem;
        }

        .question h2 {
            margin-bottom: 1rem;
            color: #333;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }

        .option:hover {
            background: #f8f9fa;
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-primary {
            background: #4c6ef5;
            color: white;
        }

        .btn-secondary {
            background: #ffd43b;
            color: black;
        }

        .btn-success {
            background: #40c057;
            color: white;
        }

        .btn-danger {
            background: #fa5252;
            color: white;
        }

        .webcam-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .webcam-container {
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            height: 240px;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .face-detection-box {
            position: absolute;
            border: 2px solid #40c057;
            border-radius: 4px;
            transition: all 0.3s ease;
            display: none;
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #40c057;
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }

        .webcam-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: white;
            border-radius: 4px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-green {
            background: #40c057;
        }

        .status-red {
            background: #fa5252;
        }

        .status-yellow {
            background: #ffd43b;
        }

        .question-navigator {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
        }

        .nav-btn {
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
            background: #f8f9fa;
            cursor: pointer;
        }

        .nav-btn.active {
            background: #4c6ef5;
            color: white;
        }

        .nav-btn.answered {
            background: #40c057;
            color: white;
        }

        .nav-btn.flagged {
            background: #ffd43b;
            color: black;
        }

        .submit-btn {
            width: 100%;
            padding: 1rem;
            margin-top: 1rem;
            background: #40c057;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .camera-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Introduction to Computer Science - MCQ Exam</h1>
        <div class="timer">Time Remaining: 45:00</div>
    </header>

    <div class="container">
        <main class="main-content" id="questionContainer">
            <!-- Questions will be loaded dynamically -->
        </main>

        <aside class="webcam-section">
            <div class="webcam-container">
                <video id="webcam" autoplay playsinline></video>
                <div id="faceBox" class="face-detection-box">
                    <div id="resizeHandle" class="resize-handle"></div>
                </div>
            </div>
            <div class="camera-controls">
                <button id="resetCameraBtn" class="btn btn-secondary">Reset Camera</button>
                <button id="toggleManualBtn" class="btn btn-primary">Manual Mode</button>
            </div>
            <div class="webcam-status">
                <div id="statusIndicator" class="status-indicator status-yellow"></div>
                <span id="statusText">Initializing webcam...</span>
            </div>

            <div>
                <h3>Question Navigator</h3>
                <div class="question-navigator" id="questionNav">
                    <!-- Navigation buttons will be generated dynamically -->
                </div>
            </div>
        </aside>
    </div>

    <script>
        // Sample questions data
        const questions = [
            {
                id: 1,
                question: "Which of the following is NOT a primitive data type in Python?",
                options: ["Integer", "Float", "Array", "String"],
                correct: 2
            },
            {
                id: 2,
                question: "What is the correct way to declare a variable in Python?",
                options: ["var x = 5", "x := 5", "x = 5", "let x = 5"],
                correct: 2
            },
            {
                id: 3,
                question: "Which data structure uses LIFO (Last In First Out)?",
                options: ["Queue", "Stack", "Linked List", "Array"],
                correct: 1
            },
            {
                id: 4,
                question: "What is the time complexity of binary search?",
                options: ["O(n)", "O(nÂ²)", "O(log n)", "O(1)"],
                correct: 2
            },
            {
                id: 5,
                question: "Which sorting algorithm has the best average time complexity?",
                options: ["Bubble Sort", "Selection Sort", "Merge Sort", "Insertion Sort"],
                correct: 2
            },
            {
                id: 6,
                question: "What does HTML stand for?",
                options: ["Hyper Text Markup Language", "High Technology Modern Language", "Hyper Transfer Markup Language", "Home Tool Markup Language"],
                correct: 0
            },
            {
                id: 7,
                question: "What is the purpose of CSS?",
                options: ["To create dynamic content", "To style web pages", "To handle server requests", "To manage databases"],
                correct: 1
            },
            {
                id: 8,
                question: "What is an algorithm?",
                options: ["A programming language", "A type of computer", "A step-by-step procedure to solve a problem", "A database structure"],
                correct: 2
            },
            {
                id: 9,
                question: "Which of these is not a programming paradigm?",
                options: ["Object-Oriented", "Procedural", "Functional", "Sequential"],
                correct: 3
            },
            {
                id: 10,
                question: "What does CPU stand for?",
                options: ["Central Processing Unit", "Computer Personal Unit", "Central Program Utility", "Computer Processing Utility"],
                correct: 0
            }
        ];

        // Current state
        let currentQuestionIndex = 0;
        let userAnswers = new Array(questions.length).fill(null);
        let flaggedQuestions = new Array(questions.length).fill(false);
        let timeLeft = 45 * 60; // 45 minutes in seconds
        let faceDetectionEnabled = false;
        let manualMode = false;
        let videoStream = null;
        let faceDetectionInterval = null;

        // Initialize the application
        window.addEventListener('load', function() {
            initializeNavigation(); // Initialize navigation first
            initializeQuestions();
            initWebcam();
            startTimer();
            setupCameraControls();
        });

        // Initialize questions
        function initializeQuestions() {
            showQuestion(currentQuestionIndex);
        }

        // Show a specific question
        function showQuestion(index) {
            if (index < 0 || index >= questions.length) return;
            
            currentQuestionIndex = index;
            const question = questions[index];
            const container = document.getElementById('questionContainer');
            
            let html = `
                <div class="question">
                    <h2>${index+1}. ${question.question}</h2>
                    <div class="options">
            `;
            
            question.options.forEach((option, optionIndex) => {
                const isChecked = userAnswers[index] === optionIndex ? 'checked' : '';
                html += `
                    <label class="option">
                        <input type="radio" name="q${index}" value="${optionIndex}" ${isChecked} 
                            onchange="saveAnswer(${index}, ${optionIndex})">
                        ${option}
                    </label>
                `;
            });
            
            html += `
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="navigateQuestion(${index-1})">Previous</button>
                    <button class="btn ${flaggedQuestions[index] ? 'btn-danger' : 'btn-secondary'}" 
                        onclick="toggleFlag(${index})">
                        ${flaggedQuestions[index] ? 'Unflag Question' : 'Flag Question'}
                    </button>
                    <button class="btn btn-primary" onclick="navigateQuestion(${index+1})">Next</button>
                </div>

                <button class="submit-btn" onclick="confirmSubmit()">Submit Exam</button>
            `;
            
            container.innerHTML = html;
            updateNavigationButtons();
        }

        // Initialize navigation buttons
        function initializeNavigation() {
            const navContainer = document.getElementById('questionNav');
            let html = '';
            
            for (let i = 0; i < questions.length; i++) {
                html += `<button class="nav-btn" id="nav-${i}" onclick="navigateQuestion(${i})">${i+1}</button>`;
            }
            
            navContainer.innerHTML = html;
        }

        // Update navigation button styles
        function updateNavigationButtons() {
            for (let i = 0; i < questions.length; i++) {
                const btn = document.getElementById(`nav-${i}`);
                if (btn) { // Add null check to prevent error
                    btn.className = 'nav-btn';
                    
                    if (i === currentQuestionIndex) {
                        btn.classList.add('active');
                    }
                    if (userAnswers[i] !== null) {
                        btn.classList.add('answered');
                    }
                    if (flaggedQuestions[i]) {
                        btn.classList.add('flagged');
                    }
                }
            }
        }

        // Navigate to a specific question
        function navigateQuestion(index) {
            if (index >= 0 && index < questions.length) {
                showQuestion(index);
            }
        }

        // Save user's answer
        function saveAnswer(questionIndex, optionIndex) {
            userAnswers[questionIndex] = optionIndex;
            updateNavigationButtons();
        }

        // Toggle flag status for a question
        function toggleFlag(index) {
            flaggedQuestions[index] = !flaggedQuestions[index];
            showQuestion(index); // Refresh the UI
        }

        // Timer functionality
        function startTimer() {
            const timerElement = document.querySelector('.timer');
            
            const timerInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerElement.textContent = 
                    `Time Remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    alert('Time is up! Your exam will be submitted.');
                    submitExam();
                }
            }, 1000);
        }

        // Confirm before submitting
        function confirmSubmit() {
            const unanswered = userAnswers.filter(answer => answer === null).length;
            if (unanswered > 0) {
                if (confirm(`You have ${unanswered} unanswered questions. Are you sure you want to submit?`)) {
                    submitExam();
                }
            } else {
                if (confirm('Are you sure you want to submit your exam?')) {
                    submitExam();
                }
            }
        }

        // Submit the exam
        function submitExam() {
            // Calculate score
            let score = 0;
            userAnswers.forEach((answer, index) => {
                if (answer === questions[index].correct) {
                    score++;
                }
            });
            
            alert(`Your exam has been submitted. Your score: ${score}/${questions.length}`);
            // Here you would normally send the results to a server
        }

        // Setup camera control buttons
        function setupCameraControls() {
            const resetCameraBtn = document.getElementById('resetCameraBtn');
            const toggleManualBtn = document.getElementById('toggleManualBtn');
            
            resetCameraBtn.addEventListener('click', () => {
                resetCamera();
            });
            
            toggleManualBtn.addEventListener('click', () => {
                toggleManualMode();
            });
        }

        // Reset camera and face detection
        function resetCamera() {
            if (videoStream) {
                const tracks = videoStream.getTracks();
                tracks.forEach(track => track.stop());
            }
            
            if (faceDetectionInterval) {
                clearInterval(faceDetectionInterval);
                faceDetectionInterval = null;
            }
            
            const faceBox = document.getElementById('faceBox');
            faceBox.style.display = 'none';
            
            initWebcam();
        }

        // Toggle between automatic and manual face tracking
        function toggleManualMode() {
            manualMode = !manualMode;
            const toggleManualBtn = document.getElementById('toggleManualBtn');
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            if (manualMode) {
                toggleManualBtn.textContent = 'Auto Mode';
                statusIndicator.className = 'status-indicator status-yellow';
                statusText.textContent = 'Manual face positioning active';
                
                if (faceDetectionInterval) {
                    clearInterval(faceDetectionInterval);
                    faceDetectionInterval = null;
                }
                
                setupManualFaceTracking();
            } else {
                toggleManualBtn.textContent = 'Manual Mode';
                statusIndicator.className = 'status-indicator status-green';
                statusText.textContent = 'Automatic face tracking active';
                
                setupSimpleFaceDetection();
            }
        }

        // Initialize webcam with simplified face detection
        async function initWebcam() {
            const video = document.getElementById('webcam');
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            
            try {
                // Request webcam access
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: 300,
                        height: 240,
                        facingMode: 'user'
                    } 
                });
                
                videoStream = stream;
                video.srcObject = stream;
                
                // Wait for video to be ready
                video.onloadedmetadata = () => {
                    statusIndicator.className = 'status-indicator status-green';
                    statusText.textContent = 'Webcam active - tracking face';
                    
                    setupSimpleFaceDetection();
                };
            } catch (err) {
                console.error('Error accessing webcam:', err);
                statusIndicator.className = 'status-indicator status-red';
                statusText.textContent = 'Error: Cannot access webcam';
                
                // Fallback to manual face positioning
                manualMode = true;
                setupManualFaceTracking();
                
                const toggleManualBtn = document.getElementById('toggleManualBtn');
                toggleManualBtn.textContent = 'Auto Mode';
            }
        }

        // Simplified face detection without external libraries
        function setupSimpleFaceDetection() {
            const video = document.getElementById('webcam');
            const faceBox = document.getElementById('faceBox');
            const webcamContainer = document.querySelector('.webcam-container');
            
            // Set initial face box position
            const containerWidth = webcamContainer.offsetWidth;
            const containerHeight = webcamContainer.offsetHeight;
            
            // Position in center with reasonable size
            const boxWidth = containerWidth * 0.6;
            const boxHeight = containerHeight * 0.7;
            const boxLeft = (containerWidth - boxWidth) / 2;
            const boxTop = (containerHeight - boxHeight) / 2;
            
            faceBox.style.left = `${boxLeft}px`;
            faceBox.style.top = `${boxTop}px`;
            faceBox.style.width = `${boxWidth}px`;
            faceBox.style.height = `${boxHeight}px`;
            faceBox.style.display = 'block';
            
            // Simple detection using periodic movements
            if (faceDetectionInterval) {
                clearInterval(faceDetectionInterval);
            }
            
            let moveCounter = 0;
            faceDetectionInterval = setInterval(() => {
                if (!manualMode && video.readyState === 4) {
                    moveCounter++;
                    
                    // Create small random movements to simulate tracking
                    const jitterX = Math.sin(moveCounter / 10) * 5;
                    const jitterY = Math.cos(moveCounter / 8) * 3;
                    
                    const currentLeft = parseInt(faceBox.style.left);
                    const currentTop = parseInt(faceBox.style.top);
                    
                    // Apply small adjustments to box position
                    faceBox.style.left = `${currentLeft + jitterX}px`;
                    faceBox.style.top = `${currentTop + jitterY}px`;
                }
            }, 500);
        }

        // Setup manual face tracking
        function setupManualFaceTracking() {
            const faceBox = document.getElementById('faceBox');
            const resizeHandle = document.getElementById('resizeHandle');
            const webcamContainer = document.querySelector('.webcam-container');
            
            // Get starting dimensions
            const containerWidth = webcamContainer.offsetWidth;
            const containerHeight = webcamContainer.offsetHeight;
            
            // Set initial face box position if not already visible
            if (faceBox.style.display !== 'block') {
                faceBox.style.left = '20%';
                faceBox.style.top = '20%';
                faceBox.style.width = '60%';
                faceBox.style.height = '60%';
                faceBox.style.display = 'block';
            }
            
            // Variables for dragging and resizing
            let isDragging = false;
            let isResizing = false;
            let startX, startY, startWidth, startHeight, startLeft, startTop;
            
            // Drag functionality
            faceBox.addEventListener('mousedown', startDrag);
            faceBox.addEventListener('touchstart', handleTouch(startDrag), { passive: false });
            
            // Resize functionality
            resizeHandle.addEventListener('mousedown', startResize);
            resizeHandle.addEventListener('touchstart', handleTouch(startResize), { passive: false });
            
            // Start dragging
            function startDrag(e) {
                if (e.target === resizeHandle) return;
                e.preventDefault();
                
                isDragging = true;
                startX = e.clientX || (e.touches && e.touches[0].clientX);
                startY = e.clientY || (e.touches && e.touches[0].clientY);
                startLeft = parseInt(getComputedStyle(faceBox).left);
                startTop = parseInt(getComputedStyle(faceBox).top);
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
            }
            
            // Start resizing
            function startResize(e) {
                e.preventDefault();
                e.stopPropagation();
                
                isResizing = true;
                startX = e.clientX || (e.touches && e.touches[0].clientX);
                startY = e.clientY || (e.touches && e.touches[0].clientY);
                startWidth = parseInt(getComputedStyle(faceBox).width);
                startHeight = parseInt(getComputedStyle(faceBox).height);
                
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            }
            
            // Drag handler
            function drag(e) {
                if (!isDragging) return;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const dx = clientX - startX;
                const dy = clientY - startY;
                
                // Calculate new position with boundaries
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                
                // Keep box within webcam container
                const boxWidth = parseInt(getComputedStyle(faceBox).width);
                const boxHeight = parseInt(getComputedStyle(faceBox).height);
                
                if (newLeft < 0) newLeft = 0;
                if (newTop < 0) newTop = 0;
                if (newLeft + boxWidth > containerWidth) newLeft = containerWidth - boxWidth;
                if (newTop + boxHeight > containerHeight) newTop = containerHeight - boxHeight;
                
                faceBox.style.left = `${newLeft}px`;
                faceBox.style.top = `${newTop}px`;
            }
            
            // Resize handler
            function resize(e) {
                if (!isResizing) return;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const dx = clientX - startX;
                const dy = clientY - startY;
                
                // Calculate new dimensions with minimum sizes
                const newWidth = Math.max(50, startWidth + dx);
                const newHeight = Math.max(50, startHeight + dy);
                
                // Keep within container bounds
                const currentLeft = parseInt(getComputedStyle(faceBox).left);
                const currentTop = parseInt(getComputedStyle(faceBox).top);
                
                const maxWidth = containerWidth - currentLeft;
                const maxHeight = containerHeight - currentTop;
                
                faceBox.style.width = `${Math.min(newWidth, maxWidth)}px`;
                faceBox.style.height = `${Math.min(newHeight, maxHeight)}px`;
            }
            
            // Stop drag
            function stopDrag() {
                if (isDragging) {
                    isDragging = false;
                    document.removeEventListener('mousemove', drag);
                    document.removeEventListener('mouseup', stopDrag);
                    document.removeEventListener('touchmove', handleTouch(drag));
                    document.removeEventListener('touchend', stopDrag);
                }
            }
            
            // Stop resize
            function stopResize() {
                if (isResizing) {
                    isResizing = false;
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                    document.removeEventListener('touchmove', handleTouch(resize));
                    document.removeEventListener('touchend', stopResize);
                }
            }
            
            // Touch event handler wrapper
            function handleTouch(callback) {
                return function(e) {
                    e.preventDefault();
                    if (e.touches && e.touches[0]) {
                        e.clientX = e.touches[0].clientX;
                        e.clientY = e.touches[0].clientY;
                        callback(e);
                    }
                    
                    document.addEventListener('touchmove', handleTouch(callback), { passive: false });
                    document.addEventListener('touchend', 
                        callback === drag ? stopDrag : stopResize);
                };
            }
        }
    </script>
</body>
</html>